     1                                  ;****************************************************************************************************************************
     2                                  ;Program name: "isfloat".  This a library function contained in a single file.  The function receives a null-terminated     *
     3                                  ;array of char and either verifies that the array can be converted to a 64-bit float or denies that such a conversion is    *
     4                                  ;possible.  Copyright (C) 2022 Floyd Holliday.                                                                              *
     5                                  ;                                                                                                                           *
     6                                  ;This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public   *
     7                                  ;License version 3 as published by the Free Software Foundation.  This program is distributed in the hope that it will be   *
     8                                  ;useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.*
     9                                  ;See the GNU Lesser General Public License for more details. A copy of the GNU General Public License v3 is available here: *
    10                                  ;<https:;www.gnu.org/licenses/>.                            *
    11                                  ;****************************************************************************************************************************
    12                                  ;
    13                                  ;
    14                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3**
    15                                  ;Author information
    16                                  ;  Author name: Floyd Holliday
    17                                  ;  Author email: holliday@fullerton.edu
    18                                  ;  Author phone (wired phone in CS building): (657)278-7021
    19                                  ;
    20                                  ;Status
    21                                  ;  This software is not an application program, but rather it is a single function licensed for use by other applications.
    22                                  ;  This function can be embedded within both FOSS programs and in proprietary programs as permitted by the LGPL.
    23                                  
    24                                  ;Function information
    25                                  ;  Function name: isfloat
    26                                  ;  Programming language: X86 assembly in Intel syntax.
    27                                  ;  Date development began:  2022-Feb-28
    28                                  ;  Date version 1.0 finished: 2022-Mar-03
    29                                  ;  Files of this function: isfloat.asm
    30                                  ;  System requirements: an X86 platform with nasm installed o other compatible assembler.
    31                                  ;  Know issues: <now in testing phase>
    32                                  ;  Assembler used for testing: Nasm version 2.14.02
    33                                  ;  Prototype: bool isfloat(char *);
    34                                  ;
    35                                  ;Purpose
    36                                  ;  This function wil accept a string (array of char) and verify that it can be converted to a corresponding 64-bit 
    37                                  ;  float number or not converted to a float number.
    38                                  ;
    39                                  ;Translation information
    40                                  ;  Assemble: nasm -f elf64 -l isfloat.lis -o isfloat.o isfloat.asm
    41                                  ;
    42                                  ;Software design document:
    43                                  ;  An Execution flow chart accompanies this function.  That document will provide a better understanding of the 
    44                                  ;  algorithm used in the isfloat function than a direct reading of the source code of the function.
    45                                  
    46                                  ;========= Begin source code ====================================================================================
    47                                  ;Declaration area
    48                                  extern printf
    49                                  global isfloat
    50                                  
    51                                  null equ 0
    52                                  true equ -1
    53                                  false equ 0
    54                                  
    55                                  segment .data
    56 00000000 0A256C660A00            floatform db 10,"%lf", 10, 0
    57                                     ;This segment is empty
    58                                  
    59                                  segment .bss
    60                                     ;This segment is empty
    61                                  
    62                                  segment .text
    63                                  isfloat:
    64                                  
    65                                  ;Block that backs up almost all GPRs
    66                                  ;Back up the general purpose registers for the sole purpose of protecting the data of the caller.
    67 00000000 55                      push rbp                                          ;Backup rbp
    68 00000001 4889E5                  mov  rbp,rsp                                      ;The base pointer now points to top of stack
    69 00000004 57                      push rdi                                          ;Backup rdi
    70 00000005 56                      push rsi                                          ;Backup rsi
    71 00000006 52                      push rdx                                          ;Backup rdx
    72 00000007 51                      push rcx                                          ;Backup rcx
    73 00000008 4150                    push r8                                           ;Backup r8
    74 0000000A 4151                    push r9                                           ;Backup r9
    75 0000000C 4152                    push r10                                          ;Backup r10
    76 0000000E 4153                    push r11                                          ;Backup r11
    77 00000010 4154                    push r12                                          ;Backup r12
    78 00000012 4155                    push r13                                          ;Backup r13
    79 00000014 4156                    push r14                                          ;Backup r14
    80 00000016 4157                    push r15                                          ;Backup r15
    81 00000018 53                      push rbx                                          ;Backup rbx
    82 00000019 9C                      pushf                                             ;Backup rflags
    83                                  
    84                                  
    85                                  ;Make a copy of the passed in array of ascii values
    86 0000001A 4989FD                  mov r13, rdi                                      ;r13 is the array of char
    87                                  
    88 0000001D B800000000              mov rax, 0
    89 00000022 48BF-                   mov rdi, floatform
    89 00000024 [0000000000000000] 
    90 0000002C 4C89EE                  mov rsi, r13
    91 0000002F E8(00000000)            call printf
    92                                  
    93                                  ;Let r14 be an index of the array r13.  Initialize to integer 0
    94 00000034 4D31F6                  xor r14, r14
    95                                  
    96                                  ;Check for leading plus or minus signs
    97 00000037 41807D002B              cmp byte [r13],'+'
    98 0000003C 7407                    je increment_index
    99 0000003E 41807D002D              cmp byte[r13],'-'
   100 00000043 7503                    jne continue_validation
   101                                  increment_index:
   102 00000045 49FFC6                  inc r14
   103                                  
   104                                  continue_validation:
   105                                  
   106                                  ;Block: loop to validate chars before the decimal point
   107                                  loop_before_point:
   108 00000048 B800000000                 mov rax,0
   109 0000004D 4831FF                     xor rdi,rdi                ;Zero out rdi
   110 00000050 438A7C3500                 mov dil,byte [r13+1*r14]   ;dil is the low byte in the register rdi; reference Jorgensen, p. 10
   111 00000055 E85C000000                 call is_digit
   112 0000005A 4883F800                   cmp rax,false
   113 0000005E 7405                       je is_it_radix_point
   114 00000060 49FFC6                     inc r14
   115 00000063 EBE3                       jmp loop_before_point
   116                                  ;End of loop checking chars before the point is encountered.
   117                                  
   118                                  is_it_radix_point:
   119                                  
   120                                  ;Is the next value of the array a genuine radix point?
   121 00000065 43807C35002E            cmp byte[r13+1*r14],'.'
   122 0000006B 752C                        jne return_false
   123                                  
   124                                  ;A point has been found, therefore, begin a loop to process remaining digits.
   125                                  start_loop_after_finding_a_point:
   126 0000006D 49FFC6                      inc r14
   127 00000070 B800000000                  mov rax,0
   128 00000075 4831FF                      xor rdi,rdi
   129 00000078 438A7C3500                  mov dil,byte[r13+1*r14]
   130 0000007D E834000000                  call is_digit
   131 00000082 4883F800                    cmp rax,false
   132 00000086 75E5                        jne start_loop_after_finding_a_point
   133                                  ;End of loop processing valid digits after passing the one decimal point.
   134                                  
   135                                  ;Something other than a digit has been found.  
   136                                  ;It should be null at the end of the string.
   137 00000088 43807C350000            cmp byte [r13+1*r14],null
   138 0000008E 7509                    jne return_false
   139 00000090 48C7C0FFFFFFFF          mov rax,true
   140 00000097 EB05                    jmp restore_gpr_registers
   141                                      
   142                                  return_false:
   143 00000099 B800000000              mov rax,false
   144                                  
   145                                  restore_gpr_registers:
   146 0000009E 9D                      popf                                    ;Restore rflags
   147 0000009F 5B                      pop rbx                                 ;Restore rbx
   148 000000A0 415F                    pop r15                                 ;Restore r15
   149 000000A2 415E                    pop r14                                 ;Restore r14
   150 000000A4 415D                    pop r13                                 ;Restore r13
   151 000000A6 415C                    pop r12                                 ;Restore r12
   152 000000A8 415B                    pop r11                                 ;Restore r11
   153 000000AA 415A                    pop r10                                 ;Restore r10
   154 000000AC 4159                    pop r9                                  ;Restore r9
   155 000000AE 4158                    pop r8                                  ;Restore r8
   156 000000B0 59                      pop rcx                                 ;Restore rcx
   157 000000B1 5A                      pop rdx                                 ;Restore rdx
   158 000000B2 5E                      pop rsi                                 ;Restore rsi
   159 000000B3 5F                      pop rdi                                 ;Restore rdi
   160 000000B4 5D                      pop rbp                                 ;Restore rbp
   161                                  
   162 000000B5 C3                      ret                                     ;Pop the integer stack and jump to the address represented by the popped value.
   163                                  
   164                                  
   165                                  
   166                                  
   167                                  
   168                                  
   169                                  
   170                                  
   171                                  
   172                                  
   173                                  ;========= Begin function is_digit ==================================================================================
   174                                  
   175                                  ;****************************************************************************************************************************
   176                                  ;Program name: "is_digit".  This a library function contained in a single file.  The function receives a char parameter.  It*
   177                                  ;returns true if that parameter is the ascii value of a decimal digit and returns false in all other cases.                  *
   178                                  ;Copyright (C) 2022 Floyd Holliday.                                                                                         *
   179                                  ;                                                                                                                           *
   180                                  ;This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public   *
   181                                  ;License version 3 as published by the Free Software Foundation.  This program is distributed in the hope that it will be   *
   182                                  ;useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.*
   183                                  ;See the GNU Lesser General Public License for more details. A copy of the GNU General Public License v3 is available here: *
   184                                  ;<https:;www.gnu.org/licenses/>.                                                                                            *
   185                                  ;****************************************************************************************************************************
   186                                  ;
   187                                  ;
   188                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3**
   189                                  ;Author information
   190                                  ;  Author name: Floyd Holliday
   191                                  ;  Author email: holliday@fullerton.edu
   192                                  ;  Author phone (wired phone in CS building): (657)278-7021
   193                                  ;
   194                                  ;Status
   195                                  ;  This software is not an application program, but rather it is a single function licensed for use by other applications.
   196                                  ;  This function can be embedded within both FOSS programs and in proprietary programs as permitted by the LGPL.
   197                                  
   198                                  ;Function information
   199                                  ;  Function name: is_digit
   200                                  ;  Name selection.  This function is named is_digit to avoid confusion with an existing library function named isdigit.
   201                                  ;  Programming language: X86 assembly in Intel syntax.
   202                                  ;  Date development began:  2022-Feb-28
   203                                  ;  Date version 1.0 finished: 2022-Feb 28
   204                                  ;  Files of this function: currently is_digit is an auxillary function of isfloat, and as such does not occupy its own file.
   205                                  ;  System requirements: an X86 platform with nasm installed or other compatible assembler.
   206                                  ;  Known issues: none
   207                                  ;  Assembler used for testing: Nasm version 2.14.02
   208                                  ;  Prototype: bool is_digit(char);
   209                                  ;
   210                                  ;Purpose
   211                                  ;  This function wil accept a single char as input parameter and determine if that parameter represents a decimal digit. 
   212                                  ;
   213                                  ;Translation information if this function occupied its own file.  Currently the function is_digit resides in the same 
   214                                  ;same file as isfloat and therefore, will be assembled when isfloat is assembled.
   215                                  ;  Assemble: nasm -f elf64 -l is_digit.lis -o is_digit.o is_digit.asm
   216                                  ;
   217                                  ;Software design document:
   218                                  ;  An Execution flow chart accompanies this function.  That document will provide a better understanding of the 
   219                                  ;  algorithm used in the isfloat function than a direct reading of the source code of the function.
   220                                  
   221                                  ;========= Begin source code ====================================================================================
   222                                  ;Declaration area
   223                                  true equ -1
   224                                  false equ 0
   225                                  ascii_value_of_zero equ 0x30
   226                                  ascii_value_of_nine equ 0x39
   227                                  
   228                                  segment .data
   229                                     ;This segment is empty
   230                                  
   231                                  segment .bss
   232                                     ;This segment is empty
   233                                  
   234                                  segment .text
   235                                  is_digit:
   236                                  
   237                                  ;Block that backs up almost all GPRs
   238                                  ;Back up the general purpose registers for the sole purpose of protecting the data of the caller.
   239 000000B6 55                      push rbp                                          ;Backup rbp
   240 000000B7 4889E5                  mov  rbp,rsp                                      ;The base pointer now points to top of stack
   241 000000BA 57                      push rdi                                          ;Backup rdi
   242 000000BB 56                      push rsi                                          ;Backup rsi
   243 000000BC 52                      push rdx                                          ;Backup rdx
   244 000000BD 51                      push rcx                                          ;Backup rcx
   245 000000BE 4150                    push r8                                           ;Backup r8
   246 000000C0 4151                    push r9                                           ;Backup r9
   247 000000C2 4152                    push r10                                          ;Backup r10
   248 000000C4 4153                    push r11                                          ;Backup r11
   249 000000C6 4154                    push r12                                          ;Backup r12
   250 000000C8 4155                    push r13                                          ;Backup r13
   251 000000CA 4156                    push r14                                          ;Backup r14
   252 000000CC 4157                    push r15                                          ;Backup r15
   253 000000CE 53                      push rbx                                          ;Backup rbx
   254 000000CF 9C                      pushf                                             ;Backup rflags
   255                                  
   256                                  ;Make a copy of the passed in array of ascii values.
   257                                  ;Note that only the low one-byte of rdi is important for this function is_digit.
   258                                  ;Nevertheless, we copy the entire 8-byte register.
   259 000000D0 41BD00000000            mov r13,0
   260 000000D6 4188FD                  mov r13b,dil     ;Copy the low byte of rdi to the low byte of r13.  The other bytes of rdi are all zeros.
   261                                  
   262                                  ;Block to test if value in r13 >= ascii(0)
   263 000000D9 4983FD30                cmp r13,ascii_value_of_zero
   264 000000DD 7C12                    jl is_digit.return_false
   265                                  
   266                                  ;Block to test if value in r13 <= ascii(9)
   267 000000DF 4983FD39                cmp r13,ascii_value_of_nine
   268 000000E3 7F0C                    jg is_digit.return_false
   269                                  
   270                                  ;Return true
   271 000000E5 4831C0                  xor rax,rax  ;Set rax to zero
   272 000000E8 48C7C0FFFFFFFF          mov rax,true
   273 000000EF EB08                    jmp is_digit.restore_gpr_registers
   274                                  
   275                                  is_digit.return_false:
   276 000000F1 4831C0                  xor rax,rax  ;Set rax to zero
   277 000000F4 B800000000              mov rax,false
   278                                  
   279                                  is_digit.restore_gpr_registers:
   280                                  ;Restore all general purpose registers to their original values
   281 000000F9 9D                      popf                                    ;Restore rflags
   282 000000FA 5B                      pop rbx                                 ;Restore rbx
   283 000000FB 415F                    pop r15                                 ;Restore r15
   284 000000FD 415E                    pop r14                                 ;Restore r14
   285 000000FF 415D                    pop r13                                 ;Restore r13
   286 00000101 415C                    pop r12                                 ;Restore r12
   287 00000103 415B                    pop r11                                 ;Restore r11
   288 00000105 415A                    pop r10                                 ;Restore r10
   289 00000107 4159                    pop r9                                  ;Restore r9
   290 00000109 4158                    pop r8                                  ;Restore r8
   291 0000010B 59                      pop rcx                                 ;Restore rcx
   292 0000010C 5A                      pop rdx                                 ;Restore rdx
   293 0000010D 5E                      pop rsi                                 ;Restore rsi
   294 0000010E 5F                      pop rdi                                 ;Restore rdi
   295 0000010F 5D                      pop rbp                                 ;Restore rbp
   296                                  
   297 00000110 C3                      ret                                     ;Pop the integer stack and jump to the address represented by the popped value.
